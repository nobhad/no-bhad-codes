<!doctype html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#e0e0e0" />
    <title>Blob Animation Mockup - No Bhad Codes</title>

    <!-- Theme flash prevention -->
    <script>
      (function () {
        try {
          const savedTheme = localStorage.getItem('theme');
          const theme = savedTheme || 'light';
          document.documentElement.setAttribute('data-theme', theme);
          const themeColorMeta = document.querySelector('meta[name="theme-color"]');
          if (themeColorMeta) {
            themeColorMeta.setAttribute('content', theme === 'dark' ? '#2a2a2a' : '#e0e0e0');
          }
        } catch (e) {
          document.documentElement.setAttribute('data-theme', 'light');
        }
      })();
    </script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />

    <!-- Font Preload -->
    <link rel="preload" href="/fonts/Acme/Acme-Regular.ttf" as="font" type="font/ttf" crossorigin />

    <!-- GSAP -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/CustomEase.min.js"></script>

    <style>
      /* === DESIGN SYSTEM TOKENS === */
      :root {
        /* Colors - Light Mode */
        --color-bg-primary: #e0e0e0;
        --color-bg-secondary: #f5f5f5;
        --color-text-primary: #1a1a1a;
        --color-text-secondary: #666666;
        --color-neutral-300: #e0e0e0;
        --color-neutral-400: #9aa0a6;
        --color-dark: #1a1a1a;

        /* Blob colors from SVG */
        --blob-primary: #dc2626;
        --blob-shadow: #333333;

        /* Layout */
        --header-height: 60px;
        --footer-height: 40px;
        --container-padding: clamp(1rem, 4vw, 2rem);

        /* Transitions */
        --transition-fast: 0.2s ease;
        --transition-medium: 0.3s ease;

        /* Z-index */
        --z-header: 10;
        --z-nav: 100;
      }

      /* Dark Mode Colors */
      [data-theme="dark"] {
        --color-bg-primary: #2a2a2a;
        --color-bg-secondary: #1a1a1a;
        --color-text-primary: #ffffff;
        --color-text-secondary: #a0a0a0;
        --color-neutral-300: #2a2a2a;
        --color-dark: #ffffff;
        --blob-shadow: #1a1a1a;
      }

      /* === BASE RESET === */
      *, *::before, *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html, body {
        height: 100%;
        overflow: hidden;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background-color: var(--color-bg-primary);
        color: var(--color-text-primary);
        transition: background-color var(--transition-medium), color var(--transition-medium);
      }

      /* === HEADER === */
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: var(--header-height);
        z-index: var(--z-header);
        background-color: var(--color-bg-primary);
        transition: background-color var(--transition-medium);
      }

      .container.is--full {
        width: 100%;
        max-width: 100%;
        padding: 0 var(--container-padding);
        height: 100%;
      }

      .nav-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: 100%;
      }

      .nav-logo-row {
        font-size: 1rem;
        font-weight: 600;
        text-decoration: none;
        color: var(--color-text-primary);
        letter-spacing: 0.05em;
        text-transform: lowercase;
      }

      .nav-row__right {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .theme-button,
      .menu-button {
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        color: var(--color-text-primary);
        transition: opacity var(--transition-fast);
      }

      .theme-button:hover,
      .menu-button:hover {
        opacity: 0.7;
      }

      .icon-wrap {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .theme-icon {
        display: none;
      }

      [data-theme="light"] .sun-icon {
        display: block;
      }

      [data-theme="dark"] .moon-icon {
        display: block;
      }

      .menu-button {
        gap: 0.5rem;
      }

      .menu-button-text {
        position: relative;
        overflow: hidden;
        height: 1.2em;
      }

      .menu-button-text p {
        margin: 0;
        font-size: 0.875rem;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .menu-button-text p:last-child {
        position: absolute;
        top: 100%;
        left: 0;
      }

      .menu-button-icon {
        width: 16px;
        height: 16px;
      }

      /* === MAIN CONTENT === */
      main {
        position: fixed;
        top: var(--header-height);
        left: 0;
        right: 0;
        bottom: var(--footer-height);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      /* === BLOB ANIMATION CONTAINER === */
      .blob-container {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #blob-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      /* Blob info overlay */
      .blob-info {
        position: absolute;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        pointer-events: none;
        z-index: 1;
      }

      .blob-info h2 {
        font-size: clamp(1.5rem, 4vw, 2.5rem);
        font-weight: 700;
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--color-text-primary);
      }

      .blob-info p {
        font-size: clamp(0.875rem, 2vw, 1rem);
        color: var(--color-text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.15em;
      }

      /* === FOOTER === */
      .footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: var(--footer-height);
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--color-bg-primary);
        transition: background-color var(--transition-medium);
      }

      .footer-content {
        text-align: center;
      }

      .footer-content p {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--color-text-secondary);
        margin: 0;
      }

      /* === RESPONSIVE === */
      @media (max-width: 767px) {
        .blob-info {
          bottom: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- NAVIGATION HEADER (from actual site) -->
    <header class="header">
      <div class="container is--full">
        <nav class="nav-row">
          <a href="/" aria-label="Go to homepage" class="nav-logo-row">no bhad codes</a>
          <div class="nav-row__right">
            <button id="toggle-theme" class="theme-button" aria-label="Toggle dark/light theme">
              <div class="icon-wrap">
                <svg class="theme-icon sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <circle cx="12" cy="12" r="5" stroke="currentColor" stroke-width="2"></circle>
                  <path d="M12 2V4M12 20V22M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2"></path>
                </svg>
                <svg class="theme-icon moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3A7 7 0 0 0 21 12.79z"></path>
                </svg>
              </div>
            </button>
            <button role="button" data-menu-toggle="" class="menu-button">
              <div class="icon-wrap">
                <svg xmlns="http://www.w3.org/2000/svg" width="100%" viewBox="0 0 16 16" fill="none" class="menu-button-icon">
                  <path d="M7.33333 16L7.33333 -3.2055e-07L8.66667 -3.78832e-07L8.66667 16L7.33333 16Z" fill="currentColor"></path>
                  <path d="M16 8.66667L-2.62269e-07 8.66667L-3.78832e-07 7.33333L16 7.33333L16 8.66667Z" fill="currentColor"></path>
                  <path d="M6 7.33333L7.33333 7.33333L7.33333 6C7.33333 6.73637 6.73638 7.33333 6 7.33333Z" fill="currentColor"></path>
                  <path d="M10 7.33333L8.66667 7.33333L8.66667 6C8.66667 6.73638 9.26362 7.33333 10 7.33333Z" fill="currentColor"></path>
                  <path d="M6 8.66667L7.33333 8.66667L7.33333 10C7.33333 9.26362 6.73638 8.66667 6 8.66667Z" fill="currentColor"></path>
                  <path d="M10 8.66667L8.66667 8.66667L8.66667 10C8.66667 9.26362 9.26362 8.66667 10 8.66667Z" fill="currentColor"></path>
                </svg>
              </div>
              <div class="menu-button-text">
                <p class="p-large">Menu</p>
                <p class="p-large">Close</p>
              </div>
            </button>
          </div>
        </nav>
      </div>
    </header>

    <!-- MAIN CONTENT - BLOB ANIMATION -->
    <main>
      <div class="blob-container">
        <canvas id="blob-canvas"></canvas>
        <div class="blob-info">
          <h2>Balance</h2>
          <p>Move your mouse to interact</p>
        </div>
      </div>
    </main>

    <!-- FOOTER (from actual site) -->
    <footer class="footer">
      <div class="footer-content">
        <p>&copy; <span id="copyright-year"></span> No Bhad Codes. All rights reserved.</p>
      </div>
    </footer>

    <script>
      // Dynamic copyright year
      document.getElementById('copyright-year').textContent = new Date().getFullYear();

      // Theme toggle
      document.getElementById('toggle-theme').addEventListener('click', function() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);

        // Update theme-color meta
        const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        if (themeColorMeta) {
          themeColorMeta.setAttribute('content', newTheme === 'dark' ? '#2a2a2a' : '#e0e0e0');
        }
      });
    </script>

    <script>
      /**
       * Blob Animation - Based on balance_circle_animation.svg
       * A physics-based blob that responds to mouse/touch interaction
       * Styled to match the SVG: red circle (#dc2626) with dark shadow
       */

      let canvas, ctx;
      let blob;

      // Get CSS variable values for theming
      function getCSSVariable(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      }

      class Blob {
        constructor() {
          this.points = [];
          this._color = null;
        }

        init() {
          for (let i = 0; i < this.numPoints; i++) {
            const point = new Point(this.divisional * (i + 1), this);
            this.push(point);
          }
        }

        render() {
          const canvas = this.canvas;
          const ctx = this.ctx;
          const pointsArray = this.points;
          const points = this.numPoints;
          const center = this.center;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Solve physics for all points
          pointsArray[0].solveWith(pointsArray[points - 1], pointsArray[1]);

          let p0 = pointsArray[points - 1].position;
          let p1 = pointsArray[0].position;
          const _p2 = p1;

          // Draw shadow ellipse (from SVG - positioned below the blob)
          // SVG has shadow at cy=474.94, circle at cy=301.01, r=120
          // Shadow is ~1.45 radii below circle center
          const shadowColor = getCSSVariable('--blob-shadow') || '#333333';
          ctx.beginPath();
          ctx.ellipse(
            center.x,
            center.y + this.radius * 1.7,  // Position below the blob
            this.radius * 1.0,               // Same width as blob
            this.radius * 0.23,              // Squished ellipse for 3D effect
            0,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = shadowColor;
          ctx.fill();

          // Draw blob with 3D gradient
          ctx.beginPath();
          ctx.moveTo((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);

          for (let i = 1; i < points; i++) {
            pointsArray[i].solveWith(pointsArray[i - 1], pointsArray[i + 1] || pointsArray[0]);

            const p2 = pointsArray[i].position;
            const xc = (p1.x + p2.x) / 2;
            const yc = (p1.y + p2.y) / 2;
            ctx.quadraticCurveTo(p1.x, p1.y, xc, yc);

            p1 = p2;
          }

          const xc = (p1.x + _p2.x) / 2;
          const yc = (p1.y + _p2.y) / 2;
          ctx.quadraticCurveTo(p1.x, p1.y, xc, yc);

          ctx.fillStyle = '#dc2626';
          ctx.fill();

          requestAnimationFrame(this.render.bind(this));
        }

        push(item) {
          if (item instanceof Point) {
            this.points.push(item);
          }
        }

        set color(value) {
          this._color = value;
        }

        get color() {
          // Use CSS variable for blob color (from SVG: #dc2626)
          return this._color || getCSSVariable('--blob-primary') || '#dc2626';
        }

        set canvas(value) {
          if (value instanceof HTMLElement && value.tagName.toLowerCase() === 'canvas') {
            this._canvas = value;
            this.ctx = this._canvas.getContext('2d');
          }
        }

        get canvas() {
          return this._canvas;
        }

        set numPoints(value) {
          if (value > 2) {
            this._points = value;
          }
        }

        get numPoints() {
          return this._points || 32;
        }

        set radius(value) {
          if (value > 0) {
            this._radius = value;
          }
        }

        get radius() {
          return this._radius || 150;
        }

        set position(value) {
          if (typeof value === 'object' && value.x && value.y) {
            this._position = value;
          }
        }

        get position() {
          return this._position || { x: 0.5, y: 0.5 };
        }

        get visualCenterOffset() {
          // Calculate offset to visually center blob+shadow combo
          // Shadow is at y + radius * 1.7 below blob center
          // To center: shift blob up by half the shadow offset
          return this.radius * 0.85; // Half of 1.7 radius offset
        }

        get center() {
          return {
            x: this.canvas.width * this.position.x,
            // Shift up by visual offset to center blob+shadow combo
            y: this.canvas.height * this.position.y - this.visualCenterOffset
          };
        }

        get divisional() {
          return (Math.PI * 2) / this.numPoints;
        }

        set running(value) {
          this._running = value === true;
        }

        get running() {
          return this._running !== false;
        }
      }

      class Point {
        constructor(azimuth, parent) {
          this.parent = parent;
          this.azimuth = Math.PI - azimuth;
          this._components = {
            x: Math.cos(this.azimuth),
            y: Math.sin(this.azimuth)
          };
          this.acceleration = -0.3 + Math.random() * 0.6;
        }

        solveWith(leftPoint, rightPoint) {
          this.acceleration =
            (-0.3 * this.radialEffect +
              (leftPoint.radialEffect - this.radialEffect) +
              (rightPoint.radialEffect - this.radialEffect)) *
              this.elasticity -
            this.speed * this.friction;
        }

        set acceleration(value) {
          if (typeof value === 'number') {
            this._acceleration = value;
            this.speed += this._acceleration * 2;
          }
        }

        get acceleration() {
          return this._acceleration || 0;
        }

        set speed(value) {
          if (typeof value === 'number') {
            this._speed = value;
            this.radialEffect += this._speed * 4;  // Reduced from 5 for less extreme morph
          }
        }

        get speed() {
          return this._speed || 0;
        }

        set radialEffect(value) {
          if (typeof value === 'number') {
            this._radialEffect = value;
          }
        }

        get radialEffect() {
          return this._radialEffect || 0;
        }

        get position() {
          return {
            x: this.parent.center.x + this.components.x * (this.parent.radius + this.radialEffect),
            y: this.parent.center.y + this.components.y * (this.parent.radius + this.radialEffect)
          };
        }

        get components() {
          return this._components;
        }

        set elasticity(value) {
          if (typeof value === 'number') {
            this._elasticity = value;
          }
        }

        get elasticity() {
          return this._elasticity || 0.001;
        }

        set friction(value) {
          if (typeof value === 'number') {
            this._friction = value;
          }
        }

        get friction() {
          return this._friction || 0.0085;
        }
      }

      // Initialize blob animation
      function initBlobAnimation() {
        blob = new Blob();
        canvas = document.getElementById('blob-canvas');

        if (!canvas) {
          console.error('Blob canvas not found');
          return;
        }

        // Set canvas size
        function resize() {
          canvas.width = canvas.parentElement.clientWidth;
          canvas.height = canvas.parentElement.clientHeight;

          // Adjust blob radius based on viewport
          const minDimension = Math.min(canvas.width, canvas.height);
          blob.radius = Math.min(minDimension * 0.25, 150);
        }

        window.addEventListener('resize', resize);
        resize();

        // Mouse/touch interaction
        let oldMousePoint = { x: 0, y: 0 };
        let hover = false;

        function handlePointerMove(e) {
          const pos = blob.center;
          const clientX = e.clientX || (e.touches && e.touches[0].clientX);
          const clientY = e.clientY || (e.touches && e.touches[0].clientY);

          if (!clientX || !clientY) return;

          const diff = { x: clientX - pos.x, y: clientY - pos.y };
          const dist = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
          let angle = null;

          blob.mousePos = { x: pos.x - clientX, y: pos.y - clientY };

          if (dist < blob.radius && hover === false) {
            const vector = { x: clientX - pos.x, y: clientY - pos.y };
            angle = Math.atan2(vector.y, vector.x);
            hover = true;
          } else if (dist > blob.radius && hover === true) {
            const vector = { x: clientX - pos.x, y: clientY - pos.y };
            angle = Math.atan2(vector.y, vector.x);
            hover = false;
          }

          if (typeof angle === 'number') {
            let nearestPoint = null;
            let distanceFromPoint = 100;

            blob.points.forEach((point) => {
              if (Math.abs(angle - point.azimuth) < distanceFromPoint) {
                nearestPoint = point;
                distanceFromPoint = Math.abs(angle - point.azimuth);
              }
            });

            if (nearestPoint) {
              let strength = {
                x: oldMousePoint.x - clientX,
                y: oldMousePoint.y - clientY
              };
              strength = Math.sqrt(strength.x * strength.x + strength.y * strength.y) * 10;
              if (strength > 100) strength = 100;
              nearestPoint.acceleration = (strength / 100) * (hover ? -1 : 1);
            }
          }

          oldMousePoint.x = clientX;
          oldMousePoint.y = clientY;
        }

        window.addEventListener('pointermove', handlePointerMove);
        window.addEventListener('touchmove', handlePointerMove);

        // Initialize and start
        blob.canvas = canvas;
        blob.init();
        blob.render();

        // Intro animation with GSAP
        gsap.from('.blob-info', {
          opacity: 0,
          y: 30,
          duration: 1,
          delay: 0.5,
          ease: 'power2.out'
        });
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initBlobAnimation);
      } else {
        initBlobAnimation();
      }
    </script>
  </body>
</html>
